---
layout: post
title: 快速直方图算法以及怎样更好的写C++
categories: 算法与数据结构
description: 
keywords: 直方图, 性能优化, c++, 算法
---

直方图算法(histogram)是平时工作中经常遇到的一个算法，无论1D还是2D都有非常广泛的应用。
例如，如何统计数组中出现最多次数的元素，就是一个典型的直方图算法的应用。类似的，2D直方图也常用在图像领域。
很多时候，我们常说的投票法，也是直方图的变种。直方图算法的原理相当之简单，以至于他完全不像是一个"算法"。
最近工作中，某个场景下发现直方图成为了性能瓶颈，仔细研究了一下实现原理及其周报，特此记录。
同时，因为整个代码是c++，快速直方图的实现其实对高效写c++也很有指导和借鉴意义。

首先，我们来看下应用直方图算法的基本问题和朴素实现。

```text
问题描述：
A. 对于给定数组a[N]，数组中所有数字均为正整数，每个数字大小不超过 k，找到出现次数最多的元素，输出它的次数和值。
B. 对于给定数组a[N]，数组中所有数字均为正整数，找到出现次数最多的元素，输出它的次数和值。
```

问题 A 是我们平时遇到最最基本的情况，使用1D直方图算法求解，时间复杂度 O[N]，空间复杂度 O[k]

```text
int hist[k];
memset(hist, 0, sizeof(hist));

for(int i = 0; i < N; i++){  
  hist[a[i]] += 1;  // vote
}

int max_val{0}, max_pos{0};
for(int i = 0; i < k; i++){
   if(hist[i] > max_val){
      max_val = hist[i];
      max_pos = i;
    }
}
```

如果 a 本身不再使用，hist 也可以直接开在 a 上，这样也不需要额外的空间了。但是在实际代码中，为了兼顾可读性，我们不采用这种做法。
所有 leetcode 之类的题解到此为止，理论上并不会有更快的解法了。

问题看上去确实是非常简单，但是在某个场景下，
如果 N = 1e12， k = 1e8，量变引起质变，整个算法的效率大幅度降低。质变的原因在于，
当 k 比较小时，hist 数组所占内存很小，可以整个放到内存中，甚至可以直接加载到 L1/L2 cache 中，其中 核心的 vote 操作只需要几个指令周期即可完成。
但是 k 值较大时，hist 数组无法加载进缓存，会导致读取 hist 操作变得格外耗时。同时，k 值增大使得数的范围上限提高以至于不得不使用 size_t/u_int32_t 
来代替 u_int16_t/int，进一步加剧了这种情况的发生。

在大数据场景下，怎样快速生成一个直方图? 这个问题可能并没有想象的那么简单，直到19年还有相关论文来研究相关的算法。
一个很好的  [fast histgram benchmark in python](https://iscinumpy.gitlab.io/post/histogram-speeds-in-python/)
但是看了里面几个核心的算法，例如 numpy / fast-histgram (in C)， 发现 vote 过程基本还是暴力计算。性能上也并不太令人满意。

IMG：2022-07-28-benchmark1.png

当然，性能敏感的代码，c++永远是首选，在 git 上翻过一遍后发现 boost 实现还是里面最靠谱。摘录几个核心的技巧：
1. 选择合适的 storage，也就是上文提到的 hist，最好是连续存储，
boost 使用的是 vector(我自己测试了 vector 和裸数组，几乎无差别。)
2. 不要使用超过数据上限的数据结构。例如，如果 u_int_16 够用，就不要用 size_t。boost 使用了动态扩展的数据类型，即先用小的数据类型，
如果超过上限了就更新成大的。
3. 其他一些操作的优化，例如 sum 
4. 二维数组/多维数组转成一维数组，注意数据的空间局部性和内存的连续分配(我自己一开始使用 vector<vector<type>>来处理2D情况，确实比1D更慢)
5. 使用并行方法来进行投票。boost 把投票分成两步，第一步生成对应的index，第二步进行 vote（对于1D的情况，第一步操作可省略），
算法采用了三种并行的方式，A- 全并行，但数据量小的时候，会产生 false-sharing，以及可能会有线程不安全的风险，毕竟如果两个线程 vote 到了同一个位置就比较麻烦。
B- 并行生成 index，然后串行进行投票。C- 并行生成 index 后，对index进行排序，（或者其他类似操作），这样再串行投票的时候，保证不同线程位于不同 disjoint，线程安全和 false-sharing 的问题都可以解决。
按照我的经验，在我自己遇到的问题上，第一步的时间消耗远小于第二步（如果第一步时间消耗大，就不把它归类到直方图问题了）。因此，全串行/B-两个方法差别不大。
对于 n 较大的情况下，排序之类的操作显然不可行，任何大于 O[N] 的算法都是不可接受的。但可能基于遇到问题的特殊性，有类似的技巧可以使用。
对于方案 A-，我还没有找到太好的解决超长数组并行修改元素从而引发线程安全的问题，但是当k和n都很大时，姑且默认十几/几十个线程访问到同一位置的概率很小吧。实验上也可以保证结果的一致性。

除此之外，boost 作为通用库，还有几个比较不错的特性：
1. 实现了上文提到grow-axis方案，即一开始给了个小范围，动态扩展。
2. 如果不采用grow-axis，对数据超过上下限情况的处理。
3. 支持 chunk val 输入，会比单个点输入性能更高
3. 使用 std::atomic 来保证线程安全，但这一点我还并没有看懂。

几个文档: 
- [boost 官方主页](https://github.com/boostorg/histogram)
- [boost 源码](https://github.com/boostorg/histogram) 
- [fast histogram 方法综述](https://inspirehep.net/files/f11f733823c3418cff083c7c75a5afe3)

对照着boost源码，把我自己的代码完善了一轮，效果还不错。下面记录一些实验的细节。 













