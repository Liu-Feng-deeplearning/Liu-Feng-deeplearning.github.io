# 数论

## r2b

存在一个原根 $g$，对每个整数 $a$, 存在唯一正整数$m$, s.t. $a = g^m \ (mod P)$

使用一个额外的数组来记录 $gp[m]=i$, 如果 $a_i = g^m (mod P)$

使用另一个额外的数组 $good[k]=1 \ if \  gp[k]<L \ mod(P) \ else \ 0$

构造多项式为 $A(x) = A_0 + A_{1}x + A_{2}x^2 ...$，其中 
$A_i$ 表示 $a$ 中可表示为 $g^i$ 元素的数目

$B(x)$ 同理。

那么 $C(x) = A(x) B(x) = c_0 + c_{1}x + c_{2}x^2 ...$，
则 $C(x)$ 中 $x_k$ 的系数为 
$c_k = A_0 B_k + A_1 B_{k-1} ...$ 为 $g_0 g_k$ 的元素个数 + $g_1 g_{k-1}$ 的元素个数 ... = 
所有乘积为 $g^k$ 的元素个数

最终计算 $res = \Sigma good[k]*c[k]$ 即可

核心步骤: 通过 NTT，可以将多项式乘法转成加法，从而在 $O(N)$ 内完成。

---
# XX
--- 
对于每个整数 a ，在 模P 的意义下，存在一个原根 g，s.t. a = g^m
对于 a0～aN，可以写成 g ^ m0 ~ g^mN

同理 B ～ g^n0~g^nN

记 Ak 为 a 中 mi = k 的个数，则
A(x) = A0 + A1 X + A2 XX ...
B(x) = B0 + B1 X ...
C = A B, Ck= Sigma(A0*Bk + A1Bk-1 ....)
Ck 表示 模P == g^k(mod P) 的个数
---


这里改进了之前的 pair-wise 方法。

定义 $M(a_0, b_0)$ 为 $a_0$ 和 $b_0$ 之间的重叠段长度，M 越大，说明 $a_0$ 和 $b_0$ 表示同一speaker的可能性越高。

构造一个 N 维向量 $C$ as cost-tensor ，以下为叙述简便，假设只有三个系统。我们可以这样定义：(Note: **原文这里有个笔误**)

$$C(a_i, b_j, c_k) = -(M(a_i, b_j)+M(a_i, c_k), M(b_j, c_k))$$
  
$C(a_i, b_j, c_k)$ 刻画了 $Ca_i, b_j, c_k$ 属于同一speaker时的可能性。

接下来，问题变成需要寻找一组 $S = \{(a_{i0}, b_{j0}, c_{k0}), (a_{i1}, b_{j1}, c_{k1}), ...\}$, 
使得 $\Sigma C(S)$ 最小。一个显然的思路是使用贪心算法（原文也是这样做的），按照我自己的理解，
把 preduso-algorithm 部分重写了一下来加深理解。

```text
S = {(a_i0, b_j0, c_k0), ...}  // S 中包括了所有可能的情况
M = {empty}
R = {S}
while R is not empty：
  x = find-min(C(x) for x in R) // 排序时候就只排那些合法的 x
  M = M + x  
  R = remove(R, x) // 这里把 R 中所有和 x 有冲突的都移除    
```
算法的复杂度核心在于第五行的排序。原文这里使用的是 sort，显然如果改成 priority 队列，
速度可以更快一点。但是，在实际场景下，融合系统数 N 和说话人个数往往都很小，常数项开销占比不可忽略，
所以这里讨论复杂度意义并不是很大。
