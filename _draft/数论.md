# 数论

## A1

对于每个整数 a ，在 模P 的意义下，存在一个原根 g，s.t. a = g^m
对于 a0～aN，可以写成 g ^ m0 ~ g^mN

同理 B ～ g^n0~g^nN

记 Ak 为 a 中 mi = k 的个数，则
A(x) = A0 + A1 X + A2 XX ...
B(x) = B0 + B1 X ...
C = A B, Ck= Sigma(A0*Bk + A1Bk-1 ....)
Ck 表示 模P == g^k(mod P) 的个数

---

对每个整数 $a$, 在 模 $P$ 的意义下，存在一个原根 $g$，$s.t. a = g^m$ 
     
---


这里改进了之前的 pair-wise 方法。

定义 $M(a_0, b_0)$ 为 $a_0$ 和 $b_0$ 之间的重叠段长度，M 越大，说明 $a_0$ 和 $b_0$ 表示同一speaker的可能性越高。

构造一个 N 维向量 $C$ as cost-tensor ，以下为叙述简便，假设只有三个系统。我们可以这样定义：(Note: **原文这里有个笔误**)

$$C(a_i, b_j, c_k) = -(M(a_i, b_j)+M(a_i, c_k), M(b_j, c_k))$$
  
$C(a_i, b_j, c_k)$ 刻画了 $Ca_i, b_j, c_k$ 属于同一speaker时的可能性。

接下来，问题变成需要寻找一组 $S = \{(a_{i0}, b_{j0}, c_{k0}), (a_{i1}, b_{j1}, c_{k1}), ...\}$, 
使得 $\Sigma C(S)$ 最小。一个显然的思路是使用贪心算法（原文也是这样做的），按照我自己的理解，
把 preduso-algorithm 部分重写了一下来加深理解。

```text
S = {(a_i0, b_j0, c_k0), ...}  // S 中包括了所有可能的情况
M = {empty}
R = {S}
while R is not empty：
  x = find-min(C(x) for x in R) // 排序时候就只排那些合法的 x
  M = M + x  
  R = remove(R, x) // 这里把 R 中所有和 x 有冲突的都移除    
```
算法的复杂度核心在于第五行的排序。原文这里使用的是 sort，显然如果改成 priority 队列，
速度可以更快一点。但是，在实际场景下，融合系统数 N 和说话人个数往往都很小，常数项开销占比不可忽略，
所以这里讨论复杂度意义并不是很大。
